const fs = require("fs");
const fse = require("fs-extra");
const path = require("path");

const NL = "\r\n";

const findApps = () =>
  fs
    .readdirSync("./components/apps", { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);

const unfilteredApps = findApps().sort();
// console.log(unfilteredApps);

const foundApps = [];

for (let i in unfilteredApps) {
  if (
    fse.existsSync(
      path.join("./components", "apps", unfilteredApps[i], "manifest.json")
    )
  ) {
    foundApps.push(unfilteredApps[i]);
  }
}

console.log("Apps Available:", foundApps);

// Get the current list of enabled Apps
const appsList = fse.existsSync("./appsEnabled")
  ? "./appsEnabled"
  : "./appsEnabledDefaults";

const enabledApps = [];
if (fse.existsSync(appsList)) {
  const enabledAppsRaw = fs.readFileSync(appsList).toString().split("\n");
  for (let i in enabledAppsRaw) {
    !enabledAppsRaw[i].trim().startsWith("#") && enabledAppsRaw[i].trim() != ""
      ? enabledApps.push(enabledAppsRaw[i].trim())
      : enabledAppsRaw[i].trim().startsWith("# Unknown App:")
      ? enabledApps.push(enabledAppsRaw[i].trim().slice(14))
      : null;
  }
}
console.log("Apps Enabled:", enabledApps);
const appsEnabledFile = fs.createWriteStream("./appsEnabled");
appsEnabledFile.on("error", function (err) {
  console.error(err);
});
appsEnabledFile.write(
  "## DELETE this file to use the DEFAULTS in appsEnabledDefaults" + NL
);
appsEnabledFile.write("## Uncommented Apps are Enabled:" + NL);
enabledApps.forEach(function (app) {
  appsEnabledFile.write(
    foundApps.includes(app) ? "" : "# Unknown App: " + app + NL
  );
});
foundApps.forEach(function (app) {
  appsEnabledFile.write((enabledApps.includes(app) ? "" : "# ") + app + NL);
});
appsEnabledFile.end();

const generatedDirectoryFile = fs.createWriteStream(
  path.join("./contexts", "process", "directoryGenerated.ts")
);

let template = fs
  .readFileSync(path.join("./contexts", "process", "directoryTemplate.ts"))
  .toString()
  .replace("\r", "")
  .split("\n");
console.log("-- START TEMPLATE --\n" + template.join("\n"));
console.log("-- END TEMPLATE --");
generatedDirectoryFile.write(
  "// WARNING: This file is automatically generated from directoryTemplate.ts," +
    NL +
    "//          do NOT edit it manually!" +
    NL
);

// Original function found here: https://codereview.stackexchange.com/questions/214947/pretty-print-an-object-javascript
function prettyPrint(obj) {
  const stringify = {
      undefined: (x) => "undefined",
      boolean: (x) => x.toString(),
      number: (x) => x,
      string: (x, k) => enquote(x, k),
      object: (x) => traverse(x),
      function: (x) => x.toString(),
      symbol: (x) => x.toString(),
    },
    indent = (s) => s.replace(/^/gm, " "),
    keywords = `do if in for let new try var case else enum eval null this true
          void with await break catch class const false super throw while
          yield delete export import public return static switch typeof
          default extends finally package private continue debugger
          function arguments interface protected implements instanceof`
      .split(/\s+/)
      .reduce((all, kw) => (all[kw] = true) && all, {}),
    keyify = (s) =>
      (!(s in keywords) && /^[$A-Z_a-z][$\w]*$/.test(s) ? s : enquote(s)) +
      ": ",
    enquote = (s, k) =>
      k == "Component"
        ? s
        : s
            .replace(/([\\"])/g, "\\$1")
            .replace(/\r/g, "\\r")
            .replace(/\n/g, "\\n")
            .replace(/\t/g, "\\t")
            .replace(/^|$/g, '"'),
    traverse = (obj) =>
      [
        `{`,
        indent(
          Object.keys(obj)
            .map(
              (k) =>
                "  " + indent(keyify(k) + stringify[typeof obj[k]](obj[k], k))
            )
            .join(",\n") + ","
        ),
        `  }`,
      ]
        .filter((s) => /\S/.test(s))
        .join("\n")
        .replace(/^{\s*\}$/, "  {}");
  return traverse(obj).replace("\n", NL);
}

for (let i in template) {
  if (template[i].includes("{%processDirectoryGenerated%}")) {
    enabledApps.forEach(function (app) {
      if (foundApps.includes(app)) {
        const manifestPath = path.join(
          "./components",
          "apps",
          app,
          "manifest.json"
        );
        const manifest = JSON.parse(fs.readFileSync(manifestPath).toString());
        const component = manifest.component ? manifest.component : app;
        manifest.appData.Component = `dynamic(() => import("components/apps/${component}/component"))`;
        generatedDirectoryFile.write(
          "  " +
            app +
            ": " +
            prettyPrint(
              Object.keys(manifest.appData)
                .sort()
                .reduce((accumulator, key) => {
                  accumulator[key] = manifest.appData[key];
                  return accumulator;
                }, {})
            ) +
            "," +
            NL
        );
      }
    });
  } else {
    generatedDirectoryFile.write(
      template[i].trimEnd() + (i == template.length - 1 ? "" : NL)
    );
  }
}

generatedDirectoryFile.end();
console.log(`Generated "${generatedDirectoryFile.path}" successfully!`);
